{"ast":null,"code":"import { Observable } from 'rxjs';\nimport { StorageType } from '../constants/persistence.storage_type';\n/**\n * Internal class which is an implementation of the ICache interface. This is\n * intended to be a private class for framework use only and will not be\n * exported by the libraries modules.\n *\n * @export\n * \\@class CacheImpl\n * @template T the type of value being cached\n *\n * @author Scott O'Bryan\n * \\@since 1.0\n */\nexport var CacheImpl = function () {\n  /**\n   * Creates an instance of CacheImpl.\n   * @param {?} key\n   * @param {?} _loader\n   * @param {?} service\n   * @param {?=} config\n   */\n  function CacheImpl(key, _loader, service, config) {\n    var _this = this;\n    if (config === void 0) {\n      config = {};\n    }\n    this._loader = _loader;\n    var type = config.type || StorageType.MEMORY;\n    // For safety sake, ensure that oneUse is not present in configuration\n    service.defineProperty(this, \"_value\", key, config);\n    this._changes = service.changes({\n      key: key,\n      type: type\n    }).map(function (def) {\n      return _this._value;\n    }).publishBehavior(this._value).refCount();\n  }\n  /**\n   * Returns an observable to a cached value if one is loaded or\n   * to the value specified by the loader that was supplied when\n   * this cache was created if it is not.\n   *\n   *         single value when it's available before marking the stream\n   *         as complete.\n   * @return {?}\n   */\n  CacheImpl.prototype.get = function () {\n    var _this = this;\n    var /** @type {?} */result = this._value;\n    if (result === undefined) {\n      /*\n       * smo - if we do not have a result, then we might still have an observable from\n       * a previous call loaded in memory cache.\n       */\n      var /** @type {?} */observable = this._cachedObservable;\n      if (observable === undefined) {\n        var /** @type {?} */loaded = this._loader();\n        if (loaded && loaded instanceof Observable) {\n          var /** @type {?} */newObservable = loaded.publishLast().refCount().do(function (value) {\n            return _this._value = value;\n          }).do(function (value) {\n            return _this._cachedObservable = undefined;\n          });\n          // cache the observable before publishing\n          this._cachedObservable = newObservable;\n          return newObservable;\n        } else {\n          // static values simply get assigned immedietly\n          result = loaded;\n          this._value = result;\n        }\n      } else {\n        return observable;\n      }\n    }\n    // We have a real value so we need to make an observable that returns said value\n    return Observable.of(result);\n  };\n  /**\n   * A hot observable returning changes over time.\n   *\n   * @return {?}\n   */\n  CacheImpl.prototype.changes = function () {\n    return this._changes;\n  };\n  /**\n   * Clears the cached value forcing a reload.\n   * @return {?}\n   */\n  CacheImpl.prototype.clear = function () {\n    this._value = undefined;\n  };\n  return CacheImpl;\n}();\nfunction CacheImpl_tsickle_Closure_declarations() {\n  /** @type {?} */\n  CacheImpl.prototype._value;\n  /** @type {?} */\n  CacheImpl.prototype._cachedObservable;\n  /** @type {?} */\n  CacheImpl.prototype._changes;\n  /** @type {?} */\n  CacheImpl.prototype._loader;\n}\n//# sourceMappingURL=persistence.cache-impl.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}