{"ast":null,"code":"import { ContainerInfo } from './storage.container_info';\n/**\n * This is an internal implementation of a storage container.  It takes a PersistenceContainer\n * (which has a subset of the functionality) and straps on an info object to keep track of\n * items that are added to the container.  This class can be used for creating storage\n * containers within other storage containers.\n *\n * @export\n * \\@class PersistenceContainerImpl\n *\n * @author Scott O'Bryan\n * \\@since 1.0\n */\nexport var SubStorage = function () {\n  /**\n   * Creates an instance of SubStorage.\n   * @param {?} _namespace\n   * @param {?} _root\n   * @param {?=} _available\n   */\n  function SubStorage(_namespace, _root, _available) {\n    if (_available === void 0) {\n      _available = true;\n    }\n    this._namespace = _namespace;\n    this._root = _root;\n    this._available = _available;\n    this._info = new ContainerInfo(_namespace, _root);\n  }\n  /**\n   * Sets a value\n   *\n   * @param {?} key\n   * @param {?} value\n   * @return {?}\n   */\n  SubStorage.prototype.set = function (key, value) {\n    if (!this._available) {\n      return false;\n    }\n    var /** @type {?} */val = this._root.set(this._getNamespacedKey(key), value);\n    this._info.addAttribute(key);\n    return val;\n  };\n  /**\n   * Returns a value for a given key\n   *\n   * @param {?} key\n   * @return {?}\n   */\n  SubStorage.prototype.get = function (key) {\n    if (!this._available) {\n      return undefined;\n    }\n    var /** @type {?} */val = this._root.get(this._getNamespacedKey(key));\n    if (val === undefined) {\n      this._info.removeAttribute(key);\n    }\n    return val;\n  };\n  /**\n   * Removes a value for a given key\n   *\n   * @param {?} key\n   * @return {?}\n   */\n  SubStorage.prototype.remove = function (key) {\n    if (!this._available) {\n      return undefined;\n    }\n    this._info.removeAttribute(key);\n    return this._root.remove(this._getNamespacedKey(key));\n  };\n  /**\n   * Removes any values which have been stored using this subStorage\n   * container.\n   * @return {?}\n   */\n  SubStorage.prototype.removeAll = function () {\n    var _this = this;\n    this._info.getAttributes().forEach(function (element) {\n      _this.remove(element);\n    });\n  };\n  /**\n   * Returns true if the parent storage object is available and if the\n   * available flag was set durring instantiation\n   *\n   * @return {?}\n   */\n  SubStorage.prototype.available = function () {\n    return this._available && this._info.available();\n  };\n  /**\n   * Returns true if the value is not undefined\n   *\n   * @param {?} key\n   * @return {?}\n   */\n  SubStorage.prototype.exists = function (key) {\n    // This will also make sure the info object is up to date.\n    return this.get(key) !== undefined;\n  };\n  /**\n   * Returns a list of un-namespaced keys that have been returned by this object.\n   *\n   * @return {?}\n   */\n  SubStorage.prototype.keys = function () {\n    var _this = this;\n    // The exists will update the underlying storage object because\n    // it invokes a get.  Still, we have an attributes object that is\n    // not tied to the object in storage, hopefully.\n    return this._info.getAttributes().filter(function (key) {\n      return _this.exists(key);\n    });\n  };\n  /**\n   * @param {?} key\n   * @return {?}\n   */\n  SubStorage.prototype._getNamespacedKey = function (key) {\n    return this._namespace + '::' + key;\n  };\n  return SubStorage;\n}();\nfunction SubStorage_tsickle_Closure_declarations() {\n  /** @type {?} */\n  SubStorage.prototype._info;\n  /** @type {?} */\n  SubStorage.prototype._namespace;\n  /** @type {?} */\n  SubStorage.prototype._root;\n  /** @type {?} */\n  SubStorage.prototype._available;\n}\n//# sourceMappingURL=storage.sub_storage.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}