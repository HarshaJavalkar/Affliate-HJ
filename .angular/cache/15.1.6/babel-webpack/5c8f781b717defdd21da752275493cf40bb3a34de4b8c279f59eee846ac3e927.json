{"ast":null,"code":"import { Injectable, EventEmitter } from '@angular/core';\nimport { CacheImpl } from './persistence.cache-impl';\nimport { SubStorage } from './storage/storage.sub_storage';\nimport { StorageFactory } from './storage/storage.factory';\nimport { StorageType } from '../constants/persistence.storage_type';\n/**\n * Service used to persist application wide storage.  Iterms may be obtained from the Service\n * itself or used through proxies.  This framework also supports an immutable flag which will\n * instruct the service that the objects stored within should not have any side-effects when\n * objects on the outside are changed.\n *\n * Note on immutability: Only clonable objects will be saved when the immutable flag is\n * set.  This framework will do a deep clone of the objects in question, but items such\n * as functions will not be preserved.  Also, immutability is slower.  If you have objects\n * that are well controlled with a single component, it is suggested that you don't save your\n * item as immutable.\n *\n * @export\n * \\@class PersistenceService\n *\n * @author Scott O'Bryan\n * \\@since 1.0\n */\nimport * as ɵngcc0 from '@angular/core';\nexport var PersistenceService = function () {\n  function PersistenceService() {\n    this._emitter = new EventEmitter();\n    this._storage = StorageFactory.getStorage();\n  }\n  /**\n   * Returns a hot observable that can be used to monitor changes to this framework over\n   * time.  Subscribing to this observable has the potential of causing memory leaks,\n   * so each subscriber is expected to unsubscribe when notifications are no longer\n   * needed.\n   *\n   *                                  results.  If not provided, all changes will be\n   *                                  returned.\n   *\n   *                                  to this framework over time.\n   * @param {?=} config\n   * @return {?}\n   */\n  PersistenceService.prototype.changes = function (config) {\n    if (config === void 0) {\n      config = {};\n    }\n    var /** @type {?} */observable = this._emitter.asObservable();\n    // apply the key filter\n    if (config.key) {\n      observable = observable.filter(function (val) {\n        return val.key === config.key;\n      });\n    }\n    // apply the type filter\n    if (config.type) {\n      observable = observable.filter(function (val) {\n        return val.type === config.type;\n      });\n    }\n    return observable;\n  };\n  /**\n   * Returns an object from storage.  If the object was stored with the immutable flag\n   * set, then the object returned will not have any side-effects into the stored model\n   * until it is set again.\n   *\n   * @param {?} key\n   * @param {?=} type\n   * @return {?}\n   */\n  PersistenceService.prototype.get = function (key, type) {\n    if (type === void 0) {\n      type = StorageType.MEMORY;\n    }\n    var /** @type {?} */storage = this._getStorage(type);\n    var /** @type {?} */value = storage.get(key);\n    // the value here will actually be an object with some metadata attached.  This\n    // is done to handle immutable and some other things.\n    if (value) {\n      var /** @type {?} */currDate = Date.now();\n      // if we have a value, we need to check to see if its expired.\n      if (value.expireAfter && value.created + value.expireAfter < currDate) {\n        storage.remove(key);\n        this._emitter.emit({\n          key: key,\n          type: type\n        });\n        return undefined;\n      }\n      // handle the oneUse configuration\n      if (value.oneUse) {\n        storage.remove(key);\n        this._emitter.emit({\n          key: key,\n          type: type\n        });\n        return value.data;\n      }\n      // if maxAge then we need to update the expires tag\n      if (value.timeout) {\n        if (value.lastAccessed + value.timeout < currDate) {\n          storage.remove(key);\n          this._emitter.emit({\n            key: key,\n            type: type\n          });\n          return undefined;\n        } else {\n          value.lastAccessed = currDate;\n          storage.set(key, value);\n        }\n      }\n      return value.data;\n    }\n    return undefined;\n  };\n  /**\n   * Puts an object into storage, replacing any item that may be in there.  By default,\n   * the object is stored as-is, which means that when other areas of code get the\n   * object, they can mutate it.\n   *\n   * As immutable storage is slower, and the reconstituted logic may be\n   * missing functions or metadata, it is recommended to use this only\n   * if you need to ensure the integrity of the stored object on each set\n   * as might be the case if you make use of the \"change\" emitter.\n   *\n   * @param {?} key\n   * @param {?} value\n   * @param {?=} config\n   * @return {?}\n   */\n  PersistenceService.prototype.set = function (key, value, config) {\n    if (config === void 0) {\n      config = {};\n    }\n    if (!config.type) {\n      config.type = StorageType.MEMORY;\n    }\n    if (!value === undefined) {\n      this.remove(key);\n      this._emitter.emit({\n        key: key,\n        type: config.type\n      });\n      return true;\n    }\n    var /** @type {?} */storage = this._getStorage(config.type);\n    var /** @type {?} */currDate = Date.now();\n    var /** @type {?} */success = storage.set(key, {\n      data: value,\n      expireAfter: config.expireAfter,\n      timeout: config.timeout,\n      oneUse: config.oneUse ? true : false,\n      created: currDate,\n      lastAccessed: currDate\n    });\n    // happens if the info object or storage object cannot be saved.\n    // Ensure we have cleaned up.\n    if (success) {\n      // this seems kind of wierd, but if we are using an immutable \n      // storage type, we want the emitter\n      this._emitter.emit({\n        key: key,\n        type: config.type\n      });\n    } else {\n      storage.remove(key);\n    }\n    return success;\n  };\n  /**\n   * Clears a value stored in the service for the given type.\n   *\n   * @param {?} key\n   * @param {?=} type\n   * @return {?}\n   */\n  PersistenceService.prototype.remove = function (key, type) {\n    if (type === void 0) {\n      type = StorageType.MEMORY;\n    }\n    var /** @type {?} */storage = this._getStorage(type);\n    var /** @type {?} */currentItem = this.get(key, type);\n    if (currentItem !== undefined) {\n      storage.remove(key);\n      this._emitter.emit({\n        key: key,\n        type: type\n      });\n    }\n    return currentItem;\n  };\n  /**\n   * Clears all stored items for a particular storage type.\n   *\n   * @param {?=} type\n   * @return {?}\n   */\n  PersistenceService.prototype.removeAll = function (type) {\n    var _this = this;\n    if (type === void 0) {\n      type = StorageType.MEMORY;\n    }\n    var /** @type {?} */keys = this._getStorage(type).keys();\n    this._getStorage(type).removeAll();\n    keys.forEach(function (key) {\n      return _this._emitter.emit({\n        key: key,\n        type: type\n      });\n    });\n  };\n  /**\n   * Cleans up any expired objects in the cache.\n   *\n   * @param {?=} type\n   * @return {?}\n   */\n  PersistenceService.prototype.clean = function (type) {\n    if (type === void 0) {\n      type = StorageType.MEMORY;\n    }\n    var /** @type {?} */storage = this._getStorage(type);\n    var /** @type {?} */keys = storage.keys();\n    var /** @type {?} */currDate = Date.now();\n    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n      var key = keys_1[_i];\n      var /** @type {?} */item = storage.get(key);\n      // if we have a value, we need to check to see if its expired.\n      if (item && (item.expireAfter && item.created + item.expireAfter < currDate || item.timeout && item.lastAccessed + item.timeout < currDate)) {\n        this.remove(key);\n      }\n    }\n  };\n  /**\n   * Create a property on the object that is bound to this stored value.  This method\n   * requires ES5 compatibility and the property will have special rules associated\n   * with it.  The name of the property will be \"key\", and the value stored in the\n   * configured storage will be prefix + key.\n   *\n   * @template T the type of property\n   * @param {?} obj\n   * @param {?} propName\n   * @param {?} key\n   * @param {?=} config\n   * @return {?}\n   */\n  PersistenceService.prototype.defineProperty = function (obj, propName, key, config) {\n    var _this = this;\n    if (config === void 0) {\n      config = {};\n    }\n    var /** @type {?} */type = config.type || StorageType.MEMORY;\n    Object.defineProperty(obj, propName, {\n      enumerable: true,\n      configurable: true,\n      get: function () {\n        return _this.get(key, type);\n      },\n      set: function (val) {\n        _this.set(key, val, config);\n      }\n    });\n  };\n  /**\n   * Returns a facade that makes things a bit easier when interacting with the service.\n   * The facade will use the prefix in order to isolate they keystore.  If no prefix is\n   * defined, the keystore will be mapped as usual with the keys working as-is in the\n   * storage.\n   *\n   * @param {?} namespace\n   * @param {?=} config the config for the facade\n   * @return {?} a PersistenceFacade object representing this store\n   */\n  PersistenceService.prototype.createContainer = function (namespace, config) {\n    if (config === void 0) {\n      config = {};\n    }\n    var /** @type {?} */thisService = this;\n    var /** @type {?} */myConfig = {\n      oneUse: config.oneUse,\n      expireAfter: config.expireAfter,\n      timeout: config.timeout,\n      type: config.type || StorageType.MEMORY\n    };\n    // Return a substorage of the service so the full config can be used.\n    return new SubStorage(namespace, {\n      get: function (key) {\n        return thisService.get(key, myConfig.type);\n      },\n      set: function (key, value) {\n        return thisService.set(key, value, myConfig);\n      },\n      remove: function (key) {\n        return thisService.remove(key, myConfig.type);\n      },\n      removeAll: function () {\n        return thisService.removeAll();\n      }\n    }, true);\n  };\n  /**\n   * Returns a cache proxy that makes interacting with this service a little bit easier.  The\n   * proxy returned will have a set key, a generic loader, and a consistent set of config\n   * parameters. Please note that the \"expires\" property of the config might have unforseen\n   * side-effects to the cache in that if the expires setting is already passed, the cache will\n   * no longer cache values until a new proxy is created.\n   *\n   * @param {?} key    they key for the item in the persistence layer\n   * @param {?} loader the function to load the intiial value.  Must return either a value or\n   *               an Observable of that value.  If an observable is returned, it will be\n   *               converted into a single by this method and returned to the subscriber.\n   * @param {?=} config optional config object used to \"set\" the value if it has not already\n   *               been loaded.  If a \"type\" is not specified, memory storage will be\n   *               used.\n   *\n   * @return {?} a CacheProxy that can be used to interact with this cache.\n   */\n  PersistenceService.prototype.createCache = function (key, loader, config) {\n    if (config === void 0) {\n      config = {};\n    }\n    // for safety ensure that oneUse is not present.  It shouldn't be, but sometimes\n    // typescript doesn't always catch errors\n    var /** @type {?} */myConfig = {\n      type: config.type || StorageType.MEMORY,\n      expireAfter: config.expireAfter,\n      timeout: config.timeout\n    };\n    return new CacheImpl(key, loader, this, myConfig);\n  };\n  /**\n   * @param {?} type\n   * @return {?}\n   */\n  PersistenceService.prototype._getStorage = function (type) {\n    return this._storage.of(type);\n  };\n  /**\n   * @param {?} maxAge\n   * @return {?}\n   */\n  PersistenceService.prototype._calculateExpires = function (maxAge) {\n    return maxAge ? Date.now() + maxAge : undefined;\n  };\n  /** @nocollapse */\n  PersistenceService.ctorParameters = function () {\n    return [];\n  };\n  PersistenceService.ɵfac = function PersistenceService_Factory(t) {\n    return new (t || PersistenceService)();\n  };\n  PersistenceService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: PersistenceService,\n    factory: function (t) {\n      return PersistenceService.ɵfac(t);\n    }\n  });\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n  return PersistenceService;\n}();\nfunction PersistenceService_tsickle_Closure_declarations() {\n  /** @type {?} */\n  PersistenceService.decorators;\n  /**\n   * @nocollapse\n   * @type {?}\n   */\n  PersistenceService.ctorParameters;\n  /** @type {?} */\n  PersistenceService.prototype._emitter;\n  /** @type {?} */\n  PersistenceService.prototype._storage;\n}\n\n//# sourceMappingURL=persistence.service.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}