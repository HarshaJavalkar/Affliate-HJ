{"ast":null,"code":"/**\n * This is a cache that also implements the <code>CanActivate</code> and <code>Resolve<T></code>\n * interfaces in angular so that it can be used as both a provider and a set of guards for Angular\n * routing.  By implementing the abstract <code>getCache<T></code> method using a cache object,\n * this abstract class can form the foundation for a service based off of the persistence framework.\n *\n * @export\n * @abstract\n * \\@class AbstraceCachedService\n * @template T - the type of value returned by this service.\n *\n * @author Scott O'Bryan\n * \\@since 1.0\n * @abstract\n */\nexport var AbstractCachedService = function () {\n  function AbstractCachedService() {}\n  /**\n   * Returns an {Observable<T>} which will monitor changes to the\n   * cache over a period of time.  This is a hot, multi-value\n   * observable which will emit the cached value, if one exists,\n   * when the Observable is first subscribed to.  The observer will\n   * then emit a new event each time the cache changes.\n   *\n   * As this is a multi-value observer which is not expected to\n   * complete, it is the responsiblity of the subscriber to\n   * unsubscribe in order to prevent potential memory leaks.\n   *\n   *          the value in the cache changes\n   * @return {?}\n   */\n  AbstractCachedService.prototype.changes = function () {\n    return this.getCache().changes();\n  };\n  /**\n   * Returns an {Observable<T>} to a cached value if one is loaded\n   * or to the value specified by the loader that was supplied when\n   * this cache was created if it is not.\n   *\n   * This Observable is guarenteed to be a single observable which\n   * means it returns a single value before it completes.  As such\n   * you do not have to unsubscribe from this Observable.\n   *\n   *          value.\n   * @return {?}\n   */\n  AbstractCachedService.prototype.get = function () {\n    return this.getCache().get();\n  };\n  /**\n   * Manually clears the value in the cache forcing a reload.\n   *\n   * @abstract\n   * @return {?}\n   */\n  AbstractCachedService.prototype.clear = function () {\n    return this.getCache().clear();\n  };\n  /**\n   * Returns the observable to the current cached service for use in the angular Router.\n   * This is equivalent to the get method but implements the resolve interface for the\n   * Angular Router.\n   *\n   * @param {?} route\n   * @param {?} state\n   * @return {?}\n   */\n  AbstractCachedService.prototype.resolve = function (route, state) {\n    return this.get();\n  };\n  /**\n   * Returns true if the value of the cached observable is \"truthy\" and false if it is not.\n   *\n   *\n   * \\@memberOf AbstraceCachedService\n   * @param {?} route\n   * @param {?} state\n   * @return {?}\n   */\n  AbstractCachedService.prototype.canActivate = function (route, state) {\n    return this.get().map(function (val) {\n      return val ? true : false;\n    });\n  };\n  /**\n   * Returns a cache that this service will use to return values.  The Cache may be obtained\n   * from the PersistenceService or it may be a custom implementation should one be needed.\n   *\n   * @protected\n   * @abstract\n   * @template T\n   * @abstract\n   * @return {?}\n   */\n  AbstractCachedService.prototype.getCache = function () {};\n  return AbstractCachedService;\n}();\n//# sourceMappingURL=persistence.cached_service.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}